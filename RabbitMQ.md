# 消息队列

## 一： 什么是消息队列

从通信说起，我想你肯定码过通信相关的代码吧，比如说TCP通信，比如说UDP通信.

它们有一个特点，就是

要么发送端和接受端同时在线，皆大欢喜，你能发送，我能收到

要么接受端挂掉了，如果是UDP的，发送端照样发送，如果是TCP的，发送端会报错

这带来一个潜在的问题

如果消息是很重要呢？

要么发出去被丢弃，要么发出去报错。不管是哪种情况，这个消息都是废了的。

同步的通信模型会出现这种问题。

这个时候，消息队列这个新东西的横空出世了。

它可以**帮发送端把消息存在一个队列中，等到接受端在线时再接受这个消息，提供了一种异步的通信方式**

它的**作用**也体现在这

## 二：消息队列的名词解释

- Producer：消息生产者，负责产生和发送消息到 Broker；也叫发送端

- Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；

- > 如果说消息队列要有一个服务器，估计就是这货了

- Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；也叫接受端

## 三：消息队列的特性

1. 异步，减少了同步的等待时间

2. 松耦合，发送端和接口端只需指定消息队列的服务器，并与之通信即可，不用关心和对方通信的是人是狗

3. 分布式，说白了就是一个发送端，可以有多个接受端，一个接受端挂了，千千万万个接受端站起来了。

4. 可靠性，发送端发送消息过去后，消息一般都是存储在本地硬盘里面，直到接受端接受消息，可以选择继续存储或者直接销毁。

   在此之前，消息是安全的，即使发送端，接受端，服务器全挂掉。重启后还是能取到消息的

   ​

   ​



## 二 ：RabbitMQ

### 2.1 what is？

消息队列的提出只是一种思路，其实现还是要靠各位大佬去开发开源软件。

RabbitMQ就是其中一种，相对来说比较流行啦

### 2.2怎么安装（rpm格式）

安装前提

`rabbitmq-server-3.7.3-1.el7` rpm安装包

`centos7 3.10.0-514.el7.x86_64` 操作系统

如果不满足前提，请查找其他解决方案

第一步：使用 ` rpm -ivh 安装包名` 安装	Rabbit软件

> 如果提示需要依赖的话。。
>
> 笔者就遇到两个依赖没装，分别是`erlang`和`socat`
>
> `socat`这个的话直接`yum install socat`即可成功安装
>
> `erlang` 这个稍微有点麻烦
>
> 两种解决方案
>
> 1. 添加repo仓库，直接`yum install erlang`  安装 ，但是repo仓库里面的erlang是古董级的
>
> 2. `erlang` 这个依赖可以通过EPEL仓库安装，但是据说仓库里面的依赖是比较古老的。
>
>    ........所以我用惨痛的经验告诉你们，仓库里面的源真是太古老了，版本要求不够。
>
>    ........所以我继续用惨痛的经验告诉你们，从源代码编译erlang简直丧心病狂，各位对自己能力有信心的，亦或是抖S的，欢迎尝试，成功了一定要告诉我。。。
>
>    .......所以如果你的系统如果是centos7的，恭喜你了。
>
>    RabbitMQ官网也是知道erlang安装的依赖太变态了，提供了一个专用的安装包，仅为RabbitMQ而用
>
>    你不用安装什么鬼依赖了
>
>    当然，不提供`OpenSSL/libcrypto`这个依赖，你需要自己安装。嘛，出来混，总是要还的
>
>    进入这个地址看下吧
>
>    `http://www.rabbitmq.com/install-rpm.html`
>
>    看看`(http://www.rabbitmq.com/install-rpm.html#install-erlang)`

第二步：恭喜你打败第一关的大BOSS了，接下来

安装后的RabbitMQ默认不会开启守护线程，如果想在系统启动时开启守护线程

用root用户执行此命令`chkconfig rabbitmq-server on`

好了，安装完毕。以上。

### 2.4 启动，停止RabbitMQ的Server

启动server：`service rabbitmq-server start`

停止server：`service rabbitmq-server stop`

### 2.5 配置RabbitMQ服务

系统启动时，以管理员身份启动应用程序

`chkconfig rabbitmq-server on`

> 创建RabbitMQ 服务



### 2.6 端口访问

确保可以越过防火墙访问到以下端口

`4369`   `5672`  `25672` `15672` `61613, 61614` `1883, 8883` `15674` `15675` 

至于原因，我不说，你们也应该知道的吧

当然，这些端口也可以更改的，自己找文档吧

  

### 2.7: 默认用户访问

未配置的情况下，默认Rabbit会使用

用户名：`guest`

密码 : `guest`

来创建一个用户

这个用户只能在本地回环地址访问RabbitMQ的后台管理页面时可用。

外网用不了这个用户，所以如果你想通过外网访问到后台管理页面

得赶紧去创建一个可用的用户

详情请查看访问控制

### 2.8 访问控制

首先这里要定义一下认证和授权

这两者通常会被混淆，这里必须理清楚一下

认证是指识别用户是谁

授权是指确定用户能做什么，不能做什么



关于访问控制。

在RabbitMQ Server开始启动时并检测到数据库未初始化或者已被删除的话，就会使用下列信息初始化新的数据库

一个虚拟主机名为`/`

用户名为`guest`密码 为`guest`被授予虚拟主机的所有权限

该用户只能通过本地回环地址访问到服务器，这是通过配置文件`loopback_users` 项进行配置的

如果你想让guest用户在任何地址上都可以登陆连接到服务器，在配置文件里面，把这项改一下

`loopback_users = none`

### 2.9 相关位置

#### 2.9.1 日志文件相关位置

假设您是在centos7，用rpm安装的rabbitMq，且没有自定义日志文件位置。

那您的日志文件位置，就在`vi /var/log/rabbitmq/`文件夹里面

如果不是，请参考官方文档的说明，人家说的很清楚了哦

`https://www.rabbitmq.com/relocate.html`

#### 2.9.2 配置文件位置

配置文件的位置要通过配置文件来看，一般来说，RabbitMq启动时，会在日志文件打上一行

```
 node           : rabbit@vm
 home dir       : /var/lib/rabbitmq
 config file(s) : (none)
 cookie hash    : OWrKEz6Wv/80qmgpmYITTg==
 log(s)         : /var/log/rabbitmq/rabbit@vm.log
                : /var/log/rabbitmq/rabbit@vm_upgrade.log
 database dir   : /var/lib/rabbitmq/mnesia/rabbit@vm
```

没错，config file后面跟着的，就是配置文件路径，但是你也看到了，我现在是none...(某些同学可能是NotFound)

这两种情况，都提醒你要自己创建配置文件了

1. 首先，要创建配置文件的路径应该和官网提到的配置文件路径的默认值一致

   如果你的按照过程与我一致，那么你的配置文件也应该要创建在

   ` /etc/rabbitmq/`

   至于文件的内容，如果你的rabbitMq的版本大于`3.7.0`则文件内容应该是`key=value`

   格式，也被称为`sysctl格式`

   有一个示例的配置文件

   `https://github.com/rabbitmq/rabbitmq-server/blob/v3.7.x/docs/rabbitmq.conf.example`

   有些高级配置，用简单的key—value配置难以配置，就可以配成`advanced.config`

   这个文件的内容和位置就不在此描述了，各位可以去官网看下

### 3.0 应用

首先要知道RabbitMq是什么，我们可以把它认为，它是一个邮局，它接受和转发二进制信息

RabbitMq有队列，可以把它认为是邮局里面的邮箱。

发送方可以把数据送到邮箱里面。

但是和传统的邮局不同，RabbitMq可以把这个邮箱里面的数据分发给很多接受者

对了，在RabbitMq里面，发送方被称为生产者，接受方被称为消费者

#### 3.1 一个HELLO_WORLD

程序目的:用Java实现一个发送方和接受方

代码在项目里面：`com.cxh.send.Sender`类的main方法以及`com.cxh.receive.Receiver`类的`main`方法

值得注意的是，如果你的rabbitMq刚安装，就火急火燎的在远程机测试这个`Hello_world`功能。

告诉你，必挂无疑。

会提示是说验证失败什么鬼的

为了能正常运行`Hello_world`功能,你需要查看访问控制那一章，把RabbitMq配置为`guest`

用户可以从远程IP访问。

当然，程序内也要设置好远程访问的用户名密码

用这个方法能体会到RabbitMq消息队列的几个特点

1. 异步接受，接受方可以不在线，发送方可以直接发送，当接受方在线时，就会接受到来自发送方的消息
2. 队列的含义，按什么顺序发送消息，就会以什么顺序接受消息

#### 3.2 工作队列

在上一章中，我们探讨了一个简单的点对点的传输，但是这个功能太过简陋，根本不能应用于实际生产环境。

在生产环境中，更多的做法是将积压的工作发送到队列中，等到服务器有空闲时，再批次执行积压的工作。

当然，不止一个服务器执行工作，我们要做的是，一个生产者，多个消费者。

相关代码已加入肯德基豪华午餐。。。不对，项目中

生产者代码和消费者代码位于`com.cxh.workqueue`

特性有几个

1. 多消费者运行，将从生产者等量的获取到消息。每一个消息都只能有一个消费者接受。

   但是当消息很多时，就必须有多个消费者处理消息了

   > 举例子啊，有50个消息在队列中，但是只要两个消费者负责接送处理消息
   >
   > 那么它们最后执行的消息量可能都是25个，就是平均执行。

2. 当消费者挂了的时候，需要RabbitMq重新收回消息，把消息发给其他消费者。

   这需要稍微改下代码，基本要改的的地方有两个

   1. 把自动ack改为手动ack

   2. 当任务执行完时，发送一个确认消息告知RabbitMq我已经执完任务

   > 但是有一点容易犯的错误，就是消费者工作执行后，没有发送确认消息。
   >
   > 它的后果是致命的，消费者关闭后（等同于挂了）
   >
   > 没有被消息确认的消息将被重新发送给其他消费者去执行。
   >
   > 然后呢，消息就总是周而复始的在消费者和生产者之间传递，没有任何的消息确认使它终结使命
   >
   > 这会导致RabbitMq占的内存越来越大。
   >
   > 要想确认是这个问题，可以用这个命令查看未被消息确认的消息有哪些
   >
   > `sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged`

   3. 消息持久性，就是说，如果RabbitMq服务器也挂了咋办，消息不久丢了吗？

      当然，我们可以设置某一个队列，把队列里面的消息保存在磁盘中。

      哪怕RabbitMq一言不合就翘辫子了，重启后，仍然可以回忆之前的队列

      > 这需要声明一个新的队列，不能使用老队列，因为老的队列，他的属性不可更改

      另外，要说明一点的话，持久化不能每时每刻都发生的，在消息产生到持久化过程中。

      有一个空窗时间，在这段时间内，RabbitMq挂了，此间的消息也就没了。

      如果你的应用程序需要严格的把控空窗时间，可以使用`发布者确认`

   4. 公平派遣，为了避免RabbitMq偏爱将消息发送给某个消费者（使它不堪重负）。

      其他消费者悠哉悠哉。

      > 造成这个现象的原因是RabbitMq不知道那个消费者很忙。在他眼里，消费者都一个样。

      我们需要使用这个公平派遣，做法是酱紫的

      定义一个消费者最大并行处理数。

      当消费者有这个数目的消息还未处理完毕时，不再向它发送消息

      > 想偷懒，没门，我都知道你们手头上还有没有任务。





### 3.2 插件

RabbitMq如果你仅仅只是启动服务端，那么它的功能很单一，就是一个消息队列的服务器，充当一个消息的中转站。为了获取更多功能，添加各种特性，你就需要启动插件

现在开始逐一介绍下RabbitMq的一些插件

#### 3.2.1 管理插件

这个插件提供命令行工具和HttpAPi,用于监控和管理RabbitMq的节点和集群。

还有浏览器的UI，可以方便查看

首先启用它

`rabbitmq-plugins enable rabbitmq_management`

> 插件激活后不需要重启节点

启动完毕后，默认情况下，可以通过以下地址访问到浏览器的UI管理端

` http://localhost:15672/`

> 如果是在本地访问的话。。

如果想访问这个浏览器UI，你需要一个用户，可以使用一开始的`guest`

也可以新建一个用户，默认情况下，添加的用户没有用户标记

> 需要特定的标记，用户才能允许访问这个浏览器UI

关于如何新建用户，以及设置用户标记，先挖坑。。



其他的功能就大致略一下

有HTTP API 的TLS配置

超时配置

响应压缩

还有介绍UI界面上都是些什么东西

如何跨域请求

会话超时设置











### 3.3 RabbitMq的一些命令行

`sudo rabbitmqctl list_queues`  用于查看当前服务器有多少个队列



### 3.4 RabbitMq的用户体系

先挖坑了，可能填，可能不填。









# 三：RabbitMQ的应用

目标：实现一个高可用的服务器，支持多并发，并将并发请求压入到队列中

等到并发请求执行完毕，返回一个响应



