# 一：应用层

## 1.1  HTTPS协议

1. HTTPS协议通过HTTP来通讯，但是用TLS/SSL来加密数据

2. HTTPS的信任是通过预先安装在计算机的各类证书来提供信任的。
3. HTTPS默认使用端口443
4. HTTPS可以防止监听和中间人攻击等手段，保障信息的安全
5. 严格来讲，HTTPS并不是一个协议，而是工作于加密协议之上（如TLS/SSL）的HTTP协议的称呼

### 1.1.1 HTTPS服务器要求

必须创建一个数字证书，并交由证书颁发机构签名以被客户端的浏览器接受。

由于浏览器一般都预装了证书颁发机构的证书，所以它们可以验证该签名

证书颁发机构可以是组织的，也可以是个人的

### 1.1.2 用WireShark解析Https

读这篇文章之间，请确保你已经了解了SSL/TLS协议

其实最重要的是获取Https协议里面的信息

但是Https协议的数据是加密过的，怎么解密呢？

你需要每次对话的Sesion Key。

关键在于，你怎么拿到Session Key

本章以RestTemplate的请求为例，来讲解如果获取Session Key ，然后用在WireShark，来解密数据







## 1.2 SSL/TLS协议

SSL/TLS  协议的基本思想是公钥加密法，也就是说，客户端先向服务器请求一个公钥

然后客户端用这个公钥加密信息，发给服务端。

服务端再用私钥来解密信息

但是由于客户端向服务端请求公钥的这个过程是明文，在此次连接中，信息可能会被拦截，篡改

无法保证公钥是可信的。

因此

**公钥一般是保存在证书里面的**

还有一个问题，就是要公钥来加密比较耗资源（那对话密钥加密就不耗资源啦？）

所以，一般的做法是

每一次对话，**服务端和客户端都生成对话密钥**。

在客户端和服务端通讯中，客户端用对话密钥加密信息，服务端用对话密钥解密信息。

**对话密钥本身又用公钥加密而成**

### 1.2.1 SSL/TLS通讯的详细过程

在此之前，大致说说简略过程吧

1. 客户端向服务端索要公钥
2. 客户端和服务端协商生成对话密钥
3. 客户端和服务端使用对话密钥进行通讯

前两段，被称为握手阶段

所谓详细过程，其实重点描述的，就是握手阶段了

握手阶段涉及到四次通信

#### 1.2.1.1第一次握手

直接抛图片

![第一次握手](https://github.com/XHang/Notes/blob/master/SSL_image/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true)

客户端发出加密通讯的请求，这个请求被称为`ClientHello`

在这个请求中，客户端要告诉服务端的是

1. 我这边支持TLS/SSL的什么版本
2. 一个客户端生成的随机数，用于生成`对话密钥`
3. 客户端支持什么加密算法，可以在`Cipher Suite ` 里面看到
4. 客户端支持什么压缩算法`Compression Methods`  

> 另外提一点，在传统的TLS协议中，本次ClientHello通讯并不包括服务器的域名
>
> 如果与客户端通讯的那个服务端有多个域名，假设为A、B。
>
> 在第二次握手中，服务端需要把客户端访问的那个域名证书给客户端，你说，应该给A还是给B
>
> 废话，SSL协议肯定不知道，或许随便给一个，比如说，我本来访问的是A域名，最后给我B域名的证书。
>
> 这肯定无法信任，对吧。
>
> 解决办法：
>
> 1. 保证服务端只有一个域名，也就是说，一个Ip，仅能有一个域名
>
> 2. 改进SSL/TLS（统称加密协议）协议，没错，现在你可以看到现在`ClientHello`传输的数据都有extension的信息了，里面就包含Server_name
>
>    如果是通过域名访问的，自动带这个信息，如果是通过Ip访问的，就没有啦

#### 1.2.1.2 第二次握手

礼尚往来，上次是客户端说Hello,这次就是服务端说Hello

本次握手就是服务端与客户端通讯的过程，被称为ServerHello

这次Hello也是信息量巨大呢,包含了

1. 确认使用的加密通讯协议版本。（其实我压根就没看到其他候选的版本，全都是TLS1.2）

2. 服务端也来生成一个随机数，用来生成对话密钥

3. 选择的加密算法

4. 服务器证书

   > 为什么要服务器证书呢？
   >
   > （保障传输的服务器是可信赖的）
   >
   > 详情看1.2.2 加密通讯史

5. 如果服务端需要验证客户端的身份，这次通讯就还会带来一个要求

   要求客户端在下面的连接中，发送客户端的证书

好了，抛一张图片结束本章的讲述

![第二次握手](https://github.com/XHang/Notes/blob/master/SSL_image/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true)

#### 1.2.1.3第三次握手

上面是服务端发给客户端的。

这次是客户端发给服务端的

但是在此之前，客户端需要处理第二次握手，服务端给的信息

需要处理的有

1. 验证服务端证书的可靠性（是否过期，证书域名与实际的是否一致，证书是否由可信赖机构签发）
2. 取出服务端证书的公钥

OK，准备进行第三次握手了，这次发送的信息有

1. 随机数。由服务端的公钥加密
2. 编码改变通知，就是告诉对方，客户端已经准备好密文传输了
3. 客户端的握手阶段已经结束

#### 1.2.1.4 中场休息阶段

其实哪里有什么中场休息，做个比喻。

现在经过前三次握手，服务端和客户端都有三个随机数了

已经可以生成对话密钥了。

这三个密钥，一个是服务端生成的随机数，两个是客户端生成的随机数

#### 1.2.1.5 第四次握手

这次是服务端要对客户端做成响应

发送的信息包括

1. 编码改变通知。我服务端也准备好数据加密传输了
2. 服务端握手结束通知

#### 1.2.1.6 下面的

下面的，%￥&…………%*……&&#%￥#（全都是密文啦）

想解密上面的信息，请用我们的对话密钥解密



### 1.2.2 加密通讯史

一开始的通讯，是明文传输的，由于有中间人攻击和监听等技术的出现，才出现的密文传输

#### 1.2.2.1密文传输的起源

那一开始的密文传输，是通过通讯双方线下约定一个private key来加密/解密数据来传输的

(这种加密被称为对称加密，因为加密和解密使用的是同一个key)

只要private key 天知地知你知我知，就没有谁能知道我们说的是什么

虽然后来机器升级，猜出private key的可能性增大。

不过也只是把private key变得更长，更复杂而已，本质还是对称加密

#### 1.2.2.2 密文传输的发展

上面讲的传统对称加密在某些领域还是可用的，但是在互联网领域，就行不通了。

因为对称加密需要线下确定。但是互联网一个服务器，会和千千万万的客户端进行通信。

总不能服务器的管理者，每年召开一个私钥发布会，邀请千千万万的客户端使用者，来发布私钥吧

（这种情景，想想就很白痴）

所以非对称加密就出现了

> 所谓非对称加密，就是说加密/解密使用的密钥不一样
>
> 内容用公钥加密，用私钥解密

简单的说

假设客户端跟服务端进行通信。那么客户端需要先知道服务端的公钥，将内容用公钥加密后，再传给服务端。

服务端再用自己的私钥解密数据。

服务端和客户端不用线下见面，直接通过明文传输公钥给要加密的对方就行。

就算其他人拿到公钥，拿到加密后的数据，没私钥，也解密不了数据

用图示表示吧

```
客户端-------我要通信----------------> 服务端

客户端<-----Server Public Key-----服务端

客户端（Server Public Key  加密数据中.....）

客户端-------加密数据---------------->服务端

服务单（server private key 解密数据中......）
```

> 其实现代还在基础的非对称加密多加了一点料。
>
> 之前客户端什么都没有，服务端有私钥和公钥钥，就可以完成加密通讯
>
> 现在是客户端也要有自己的私钥和公钥。私钥加密数据的Hash值，公钥传给服务端，服务端会用客户端的公钥解码Hash值，并和数据运算出来的Hash值进行比对，以判断数据是否正确
>
> 用图示表示吧
>
> ```
> 客户端-------我要通信---------------------------------> 服务端
> 
> 客户端<-----Server Public Key-------------------------服务端
> 
> 客户端（Server Public Key  加密数据中.....）
> 客户端（client private Key  加密数据Hash值中.....）
> 
> 客户端-------加密数据,client public key---------------->服务端
> 
> 服务端（server private key 解密数据中......）
> 服务端（client public key 解密数据Hash值中......）
> 服务端（运算解密数据的Hash值......）
> 服务端（Hash值匹配，native！......）
> ```
>

#### 1.2.2.3 密文传输的危机

密文传输发展到第二代，也只不过对称加密改成非对称加密，解决了线下沟通的麻烦而已。

但是，这次发展，也给加密安全带来了危机

因为，public key是明。文。传。输。的

攻击者虽然拿到公钥和加密后的数据，不能做到什么。但是，它可以伪装成服务端。给客户端发公钥

这意味着？

好吧，假设你要跟马云合作一个12块钱的项目—买个Switch，现在到了输入交易密码的时候了

理想情况是酱紫的

```
客户端-------我要输入交易密码----------------> 服务端

客户端<-----Server Public Key-----服务端

客户端（Server Public Key  加密密码中.....）

客户端-------加密后的密码---------------->服务端

服务端（server private key 解密密码中......）

```

实际一开始的明文传输就被中间者拦截了，中间者伪造服务端发给客户端一个公钥

于是就变成了

```
客户端-------我要输入交易密码----------------> 中间者

客户端<-----Server Public Key-----中间者

客户端（Server Public Key  加密密码中.....）

客户端-------加密后的密码---------------->中间者

中间者（server private key 解密密码中......）
中间者（拿钱啦。。。）
```

错都在公钥上，任何人都可以冒充它。公钥要变成更有信服力才行！

好吧，公钥其实什么也做不了，它选择了傍大腿，那就是证书。

但是证书也不可信任怎么办。

那就让某个大家（其实是谷歌，火狐那些大佬）都认可的机构签发这个证书。

只要让客户端知道拿到的服务端证书，是可信任的机构签发的，那么躲在证书里面的公钥，就是可信赖的

> 扩展一点，客户端怎么知道拿到的服务端证书，是由可信任的机构签发的呢？
>
> 这就牵扯到服务端的证书，是怎么通过可信任的机构签发的了
>
> 服务端证书签发步骤
>
> 1. 服务端把证书信息发给证书签发机构
> 2. 证书签发机构用自己的密钥给服务端证书加密
> 3. 服务端拿到加密后的证书信息，不，应该叫做数字证书了，人家换了马甲了
>
> 服务端把数字证书发给客户端。
>
> 客户端通过系统预置的证书，取得公钥，解密服务器的数字证书。
>
> 只有系统预置的证书是可信赖的，那么解密出来的服务器证书就是可信赖的

至此，现代的加密传输原理，大致就是酱紫了，危机结束。下面是大佬时代（开玩笑的）
















