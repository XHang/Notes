# 一：应用层

## 1.1  HTTPS协议

1. HTTPS协议通过HTTP来通讯，但是用TLS/SSL来加密数据

2. HTTPS的信任是通过预先安装在计算机的各类证书来提供信任的。
3. HTTPS默认使用端口443
4. HTTPS可以防止监听和中间人攻击等手段，保障信息的安全
5. 严格来讲，HTTPS并不是一个协议，而是工作于加密协议之上（如TLS/SSL）的HTTP协议的称呼

### 1.1.1 HTTPS服务器要求

必须创建一个数字证书，并交由证书颁发机构签名以被客户端的浏览器接受。

由于浏览器一般都预装了证书颁发机构的证书，所以它们可以验证该签名

证书颁发机构可以是组织的，也可以是个人的

### 1.1.2 用WireShark解析Https

读这篇文章之间，请确保你已经了解了SSL/TLS协议

其实最重要的是获取Https协议里面的信息

但是Https协议的数据是加密过的，怎么解密呢？

你需要每次对话的Sesion Key。

关键在于，你怎么拿到Session Key

本章以RestTemplate的请求为例，来讲解如果获取Session Key ，然后用在WireShark，来解密数据

1. 下载一个jar文件

`https://repo1.maven.org/maven2/name/neykov/extract-ssl-secrets/1.0.0/extract-ssl-secrets-1.0.0.jar`

2. 保存在path路径

3. 加入VM参数

   `-javaagent:{path}=P:\logs\key.log`

   举例子

   `-javaagent:M:\java_project\WeiXin\src\main\resources\extract-ssl-secrets-1.0.0.jar=P:\logs\key.log`

   其中`P:\logs\key.log` 就是HTTPS会话的秘钥

4. 打开wireShark，打开首选项，打开协议，选择SSL协议，最下面选择log File为`P:\logs\key.log`

5. OK,开始发送HTTPS请求，你会发现它自动解密了

6. 搞定，感谢Stack Overflow

   相关链接

   `https://github.com/neykov/extract-ssl-secrets`

   `https://stackoverflow.com/questions/11591940/decrypt-client-side-ssl-traffic-in-wireshark-generated-by-java-httpsurlconnectio`

**背后原理解析**

1. `javaagent` 这是一个VM参数，它能通过编写一个文件（通常是jar）

   能实现的功能是

   1. 在类的加载之时，更改类的字节码

   2. 运行期对类的字节码进行修改，但是会有很多限制。

   3. 等等。。。

      > 对了，这货也叫探针技术

   我猜之所以能实现保存秘钥的功能，是因为这个东西修改了有关SSL类的字节码

   使之能输出秘钥

   



### 1.1.3 为你的服务器升级HTTPS

1. 给你的服务器准备一个域名。。一个免费的域名提供商是`my.freenom.com`

   > 理论上IP也可以使用HTTPS，然而，证书提供商一般不会让你用IP地址做证书的
   >
   > 要不。。PY交易。。开玩笑的

2. 准备数字证书

   当然我们没有钱，不能用收费版的HTTPS，但是幸好，有一些免费的HTTPS证书提供商是免费的

   `https://letsencrypt.org/`就是其中一个

   获取过程很简单，在linux上安装一些证书获取工具，官网也有教你怎么安装

   然后执行这个命令

   `certbot certonly --standalone -d www.thisisweb.tk`

   > 只生成证书，但是不安装，该证书将绑定到`www.thisisweb.tk`域名
   >
   > 如果要绑定到多个域名，就继续`-d xxxx`
   >
   > 然后将证书和密钥保存在`/etc/letsencrypt/live/www.thisisweb.tk/`
   >
   > `etc/letsencrypt/live/www.thisisweb.tk/privkey.pem`
   >
   > 这两个文件夹内

   完成以上任务你将获得

   证书*1（pem格式的）`cert.pem`

   密钥文件*1（pem格式的）`privkey.pem`

3. 给自己的服务器安装证书，启动HTTPS

   以Tomcat为例，tomCat支持几种TLS/SSL实现，

   一种是`JSSE`的`Java`实现

   一种是`OpenSSL`的`JSSE`实现

   一种是`OpenSSL`的`APR`实现

   默认你不配置，是自动采取实现，比如说，你的环境有APR依赖包

   则采用`OpenSSL`的`JSSE`实现

   如果没有，则采用`JSSE`的`Java`实现

   当然也可以自己手动指定

   我懒得安装Apr库，直接采取OpenSSL的JSSE实现，该实现，需要你改下server.xml

   如图所示

   ```
    <Connector port="8443" protocol="org.apache.coyote.http11.Http11Nio2Protocol"
                  maxThreads="150" SSLEnabled="true" scheme="https" secure="true">
           <SSLHostConfig certificateVerification="optional" sslProtocol="TLSv1+TLSv1.1+TLSv1.2">
               <Certificate certificateFile="/etc/letsencrypt/live/www.thisisweb.tk/cert.pem"
                            certificateKeyFile="/etc/letsencrypt/live/www.thisisweb.tk/privkey.pem"/>
           </SSLHostConfig>
       </Connector>
   ```


解释一下

这几个是固定的`SSLEnabled="true" scheme="https" secure="true"`

然后

`certificateVerification`客户端验证可选

`sslProtocol`指定加密协议

`certificateFile`指定证书文件   管网说要是pem格式的

`certificateKeyFile`指定密钥文件 管网说要是pem格式的

中间也出现几个问题

1. tomcat启动报错

   ```
   Multiple SSLHostConfig elements were provided for the host name [_default_]. Host names must be unique
   ```

   原因是`Connector`标签里面几个SSL属性是弃用的，如果你写了这几个属性，就会如此报错

   注意：截止至19/02  Tomcat8的官方指导文档还是使用了`Connector`里面的SSL属性

   可以说官方文档是过时的，但是你只要去看下这个`Connector`标签的官方文档说，它会明确告诉你，那几个属性是过时的

2. tomcat启动保存，大致意思是，嗯，不支持SSL协议：xxxx

   因为之前的配置里`protocols`里面我是填了几个值的

   没想到Tomcat不支持，于是只是去掉这个属性，让Tomcat自己去选

3. 没了，其实配置起来很简单的说

   背后的SSL协议，那才是重点，划重点，要考得

   配置完成只是说对这个SSL协议的一个应用罢了








## 1.2 SSL/TLS协议

SSL/TLS  协议的基本思想是公钥加密法，也就是说，客户端先向服务器请求一个公钥

然后客户端用这个公钥加密信息，发给服务端。

服务端再用私钥来解密信息

但是由于客户端向服务端请求公钥的这个过程是明文，在此次连接中，信息可能会被拦截，篡改

无法保证公钥是可信的。

因此

**公钥一般是保存在证书里面的**

还有一个问题，就是要公钥来加密比较耗资源（那对话密钥加密就不耗资源啦？）

所以，一般的做法是

每一次对话，**服务端和客户端都生成对话密钥**。

在客户端和服务端通讯中，客户端用对话密钥加密信息，服务端用对话密钥解密信息。

**对话密钥本身又用公钥加密而成**

### 1.2.1 SSL/TLS通讯的详细过程

在此之前，大致说说简略过程吧

1. 客户端向服务端索要公钥
2. 客户端和服务端协商生成对话密钥
3. 客户端和服务端使用对话密钥进行通讯

前两段，被称为握手阶段

所谓详细过程，其实重点描述的，就是握手阶段了

握手阶段涉及到四次通信

#### 1.2.1.1第一次握手

直接抛图片

![第一次握手](https://github.com/XHang/Notes/blob/master/SSL_image/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true)

客户端发出加密通讯的请求，这个请求被称为`ClientHello`

在这个请求中，客户端要告诉服务端的是

1. 我这边支持TLS/SSL的什么版本
2. 一个客户端生成的随机数，用于生成`对话密钥`
3. 客户端支持什么加密算法，可以在`Cipher Suite ` 里面看到
4. 客户端支持什么压缩算法`Compression Methods`  

> 另外提一点，在传统的TLS协议中，本次ClientHello通讯并不包括服务器的域名
>
> 如果与客户端通讯的那个服务端有多个域名，假设为A、B。
>
> 在第二次握手中，服务端需要把客户端访问的那个域名证书给客户端，你说，应该给A还是给B
>
> 废话，SSL协议肯定不知道，或许随便给一个，比如说，我本来访问的是A域名，最后给我B域名的证书。
>
> 这肯定无法信任，对吧。
>
> 解决办法：
>
> 1. 保证服务端只有一个域名，也就是说，一个Ip，仅能有一个域名
>
> 2. 改进SSL/TLS（统称加密协议）协议，没错，现在你可以看到现在`ClientHello`传输的数据都有extension的信息了，里面就包含Server_name
>
>    如果是通过域名访问的，自动带这个信息，如果是通过Ip访问的，就没有啦

#### 1.2.1.2 第二次握手

礼尚往来，上次是客户端说Hello,这次就是服务端说Hello

本次握手就是服务端与客户端通讯的过程，被称为ServerHello

这次Hello也是信息量巨大呢,包含了

1. 确认使用的加密通讯协议版本。（其实我压根就没看到其他候选的版本，全都是TLS1.2）

2. 服务端也来生成一个随机数，用来生成对话密钥

3. 选择的加密算法

4. 服务器证书

   > 为什么要服务器证书呢？
   >
   > （保障传输的服务器是可信赖的）
   >
   > 详情看1.2.2 加密通讯史

5. 如果服务端需要验证客户端的身份，这次通讯就还会带来一个要求

   要求客户端在下面的连接中，发送客户端的证书

好了，抛一张图片结束本章的讲述

![第二次握手](https://github.com/XHang/Notes/blob/master/SSL_image/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true)

#### 1.2.1.3第三次握手

上面是服务端发给客户端的。

这次是客户端发给服务端的

但是在此之前，客户端需要处理第二次握手，服务端给的信息

需要处理的有

1. 验证服务端证书的可靠性（是否过期，证书域名与实际的是否一致，证书是否由可信赖机构签发）
2. 取出服务端证书的公钥

OK，准备进行第三次握手了，这次发送的信息有

1. 随机数。由服务端的公钥加密
2. 编码改变通知，就是告诉对方，客户端已经准备好密文传输了
3. 客户端的握手阶段已经结束

#### 1.2.1.4 中场休息阶段

其实哪里有什么中场休息，做个比喻。

现在经过前三次握手，服务端和客户端都有三个随机数了

已经可以生成对话密钥了。

这三个密钥，一个是服务端生成的随机数，两个是客户端生成的随机数

#### 1.2.1.5 第四次握手

这次是服务端要对客户端做成响应

发送的信息包括

1. 编码改变通知。我服务端也准备好数据加密传输了
2. 服务端握手结束通知

#### 1.2.1.6 下面的

下面的，%￥&…………%*……&&#%￥#（全都是密文啦）

想解密上面的信息，请用我们的对话密钥解密



### 1.2.2 加密通讯史

一开始的通讯，是明文传输的，由于有中间人攻击和监听等技术的出现，才出现的密文传输

#### 1.2.2.1密文传输的起源

那一开始的密文传输，是通过通讯双方线下约定一个private key来加密/解密数据来传输的

(这种加密被称为对称加密，因为加密和解密使用的是同一个key)

只要private key 天知地知你知我知，就没有谁能知道我们说的是什么

虽然后来机器升级，猜出private key的可能性增大。

不过也只是把private key变得更长，更复杂而已，本质还是对称加密

#### 1.2.2.2 密文传输的发展

上面讲的传统对称加密在某些领域还是可用的，但是在互联网领域，就行不通了。

因为对称加密需要线下确定。但是互联网一个服务器，会和千千万万的客户端进行通信。

总不能服务器的管理者，每年召开一个私钥发布会，邀请千千万万的客户端使用者，来发布私钥吧

（这种情景，想想就很白痴）

所以非对称加密就出现了

> 所谓非对称加密，就是说加密/解密使用的密钥不一样
>
> 内容用公钥加密，用私钥解密

简单的说

假设客户端跟服务端进行通信。那么客户端需要先知道服务端的公钥，将内容用公钥加密后，再传给服务端。

服务端再用自己的私钥解密数据。

服务端和客户端不用线下见面，直接通过明文传输公钥给要加密的对方就行。

就算其他人拿到公钥，拿到加密后的数据，没私钥，也解密不了数据

用图示表示吧

```
客户端-------我要通信----------------> 服务端

客户端<-----Server Public Key-----服务端

客户端（Server Public Key  加密数据中.....）

客户端-------加密数据---------------->服务端

服务单（server private key 解密数据中......）
```

> 其实现代还在基础的非对称加密多加了一点料。
>
> 之前客户端什么都没有，服务端有私钥和公钥钥，就可以完成加密通讯
>
> 现在是客户端也要有自己的私钥和公钥。私钥加密数据的Hash值，公钥传给服务端，服务端会用客户端的公钥解码Hash值，并和数据运算出来的Hash值进行比对，以判断数据是否正确
>
> 用图示表示吧
>
> ```
> 客户端-------我要通信---------------------------------> 服务端
> 
> 客户端<-----Server Public Key-------------------------服务端
> 
> 客户端（Server Public Key  加密数据中.....）
> 客户端（client private Key  加密数据Hash值中.....）
> 
> 客户端-------加密数据,client public key---------------->服务端
> 
> 服务端（server private key 解密数据中......）
> 服务端（client public key 解密数据Hash值中......）
> 服务端（运算解密数据的Hash值......）
> 服务端（Hash值匹配，native！......）
> ```
>

#### 1.2.2.3 密文传输的危机

密文传输发展到第二代，也只不过对称加密改成非对称加密，解决了线下沟通的麻烦而已。

但是，这次发展，也给加密安全带来了危机

因为，public key是明。文。传。输。的

攻击者虽然拿到公钥和加密后的数据，不能做到什么。但是，它可以伪装成服务端。给客户端发公钥

这意味着？

好吧，假设你要跟马云合作一个12块钱的项目—买个Switch，现在到了输入交易密码的时候了

理想情况是酱紫的

```
客户端-------我要输入交易密码----------------> 服务端

客户端<-----Server Public Key-----服务端

客户端（Server Public Key  加密密码中.....）

客户端-------加密后的密码---------------->服务端

服务端（server private key 解密密码中......）

```

实际一开始的明文传输就被中间者拦截了，中间者伪造服务端发给客户端一个公钥

于是就变成了

```
客户端-------我要输入交易密码----------------> 中间者

客户端<-----Server Public Key-----中间者

客户端（Server Public Key  加密密码中.....）

客户端-------加密后的密码---------------->中间者

中间者（server private key 解密密码中......）
中间者（拿钱啦。。。）
```

错都在公钥上，任何人都可以冒充它。公钥要变成更有信服力才行！

好吧，公钥其实什么也做不了，它选择了傍大腿，那就是证书。

但是证书也不可信任怎么办。

那就让某个大家（其实是谷歌，火狐那些大佬）都认可的机构签发这个证书。

只要让客户端知道拿到的服务端证书，是可信任的机构签发的，那么躲在证书里面的公钥，就是可信赖的

> 扩展一点，客户端怎么知道拿到的服务端证书，是由可信任的机构签发的呢？
>
> 这就牵扯到服务端的证书，是怎么通过可信任的机构签发的了
>
> 服务端证书签发步骤
>
> 1. 服务端把证书信息发给证书签发机构
> 2. 证书签发机构用自己的密钥给服务端证书加密
> 3. 服务端拿到加密后的证书信息，不，应该叫做数字证书了，人家换了马甲了
>
> 服务端把数字证书发给客户端。
>
> 客户端通过系统预置的证书，取得公钥，解密服务器的数字证书。
>
> 只有系统预置的证书是可信赖的，那么解密出来的服务器证书就是可信赖的

至此，现代的加密传输原理，大致就是酱紫了，危机结束。下面是大佬时代（开玩笑的）
















